using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Luau.SourceGenerator;

// TODO: refactoring

internal class CreateFunctionContext : IEquatable<CreateFunctionContext>
{
    public CreateFunctionMethod? Method { get; set; }
    public required DiagnosticReporter DiagnosticReporter { get; init; }
    public required SemanticModel Model { get; init; }

    public bool Equals(CreateFunctionContext other)
    {
        return Method == other.Method;
    }

    public override bool Equals(object obj)
    {
        return obj is CreateFunctionContext ctx && Equals(ctx);
    }

    public override int GetHashCode()
    {
        return Method == null ? 0 : Method.GetHashCode();
    }
}

internal class CreateFunctionMethod : IEquatable<CreateFunctionMethod>
{
    public required CreateFunctionMethodParameter[] Parameters { get; init; }
    public required string ReturnTypeName { get; init; }
    public required bool HasReturnValue { get; init; }
    public required bool IsAsync { get; init; }
    public required string FilePath { get; init; }
    public required int LineNumber { get; init; }

    public bool Equals(CreateFunctionMethod other)
    {
        return Parameters.SequenceEqual(other.Parameters) && ReturnTypeName == other.ReturnTypeName;
    }

    public override bool Equals(object obj)
    {
        return obj is CreateFunctionMethod other && Equals(other);
    }

    public override int GetHashCode()
    {
        if (Parameters.Length == 0) return 0;
        var hashCode = Parameters[0].GetHashCode();
        for (int i = 1; i < Parameters.Length; i++)
        {
            hashCode ^= Parameters[i].GetHashCode();
        }
        hashCode ^= ReturnTypeName.GetHashCode();
        return hashCode;
    }

    public static CreateFunctionMethod Create(Location location, bool isAsync, ITypeSymbol? returnType, CreateFunctionMethodParameter[] parameters)
    {
        var returnTypeName = returnType == null ? "void" : returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        var lineSpan = location.GetLineSpan();
        var filePath = lineSpan.Path;
        var lineNumber = lineSpan.StartLinePosition.Line + 1; // 1-based

        return new CreateFunctionMethod
        {
            Parameters = parameters!,
            ReturnTypeName = returnTypeName,
            HasReturnValue = returnType != null && returnTypeName != "void" && !(isAsync && returnType is INamedTypeSymbol n && !n.IsGenericType),
            IsAsync = isAsync,
            FilePath = filePath,
            LineNumber = lineNumber,
        };
    }
}

internal record CreateFunctionMethodParameter
{
    public required string FullTypeName { get; init; }
}

[Generator(LanguageNames.CSharp)]
public class CreateFunctionGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(static context =>
        {
            context.AddSource("GeneratedLuauStateExtensions.CreateFunction.g.cs",
"""
// <auto-generated/>

namespace Luau
{
    internal static partial class GeneratedLuauStateExtensions
    {
        public static partial global::Luau.LuauFunction CreateFunction(
            this global::Luau.LuauState state,
            global::System.Delegate action,
            [global::System.Runtime.CompilerServices.CallerFilePath] string filePath = "", 
            [global::System.Runtime.CompilerServices.CallerLineNumber] int lineNumber = 0);
    }
}
""");
        });

        var queryMethodProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (node, ct) =>
                {
                    if (node.IsKind(SyntaxKind.InvocationExpression))
                    {
                        if (node is not InvocationExpressionSyntax invocationExpression) return false;

                        var expr = invocationExpression.Expression as MemberAccessExpressionSyntax;
                        var methodName = expr?.Name.Identifier.Text;
                        if (methodName is "CreateFunction")
                        {
                            return true;
                        }

                        return false;
                    }

                    return false;
                }, (context, ct) =>
                {
                    var reporter = new DiagnosticReporter();
                    var result = new CreateFunctionContext
                    {
                        DiagnosticReporter = reporter,
                        Model = context.SemanticModel,
                    };

                    var node = (InvocationExpressionSyntax)context.Node;

                    var model = context.SemanticModel.GetTypeInfo((node.Expression as MemberAccessExpressionSyntax)!.Expression, ct);
                    if (model.Type?.Name is not "LuauState") return result;

                    var actionExpression = node.ArgumentList.Arguments[0].Expression;
                    if (actionExpression is CastExpressionSyntax castExpression)
                    {
                        actionExpression = castExpression.Expression;
                    }

                    if (actionExpression is ParenthesizedLambdaExpressionSyntax lambda)
                    {
                        var parameters = lambda.ParameterList
                            .Parameters
                            .Where(x => x.Type != null)
                            .Select(x =>
                            {
                                var type = context.SemanticModel.GetTypeInfo(x.Type!);
                                var typeName = type.Type!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                                return new CreateFunctionMethodParameter
                                {
                                    FullTypeName = type.Type!.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                                };
                            })
                            .Where(x => x != null)
                            .ToArray();

                        var methodSymbol = (IMethodSymbol)context.SemanticModel.GetSymbolInfo(lambda).Symbol!;
                        result.Method = CreateFunctionMethod.Create(lambda.GetLocation(), methodSymbol.IsAsync, methodSymbol.ReturnType, parameters);
                    }
                    else
                    {
                        var symbols = context.SemanticModel.GetMemberGroup(actionExpression);
                        if (symbols.Length == 0)
                        {
                            if (actionExpression is not LambdaExpressionSyntax)
                            {
                                reporter.ReportDiagnostic(DiagnosticDescriptors.ArgumentMustBeMethodGroupOrLambda, actionExpression.GetLocation());
                            }
                            return result;
                        }

                        var symbol = symbols[0];

                        if (symbol is IMethodSymbol methodSymbol)
                        {
                            if (methodSymbol.DeclaringSyntaxReferences.Length == 0)
                            {
                                reporter.ReportDiagnostic(DiagnosticDescriptors.DefinedInOtherProject, actionExpression.GetLocation());
                                return result;
                            }

                            var parameters = methodSymbol.Parameters
                                .Select(x =>
                                {
                                    var type = x.Type!;
                                    var typeName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                                    return new CreateFunctionMethodParameter
                                    {
                                        FullTypeName = typeName,
                                    };
                                })
                                .ToArray();

                            var returnType = methodSymbol.ReturnsVoid ? null : methodSymbol.ReturnType;
                            var isAsync = returnType != null && (
                                returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Threading.Tasks.Task" ||
                                returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::System.Threading.Tasks.ValueTask" ||
                                returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::Cysharp.Threading.Tasks.UniTask" ||
                                returnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == "global::UnityEngine.Awaitable"
                            );

                            result.Method = CreateFunctionMethod.Create(actionExpression.GetLocation(), isAsync, returnType, parameters);
                        }
                        else
                        {
                            reporter.ReportDiagnostic(DiagnosticDescriptors.ArgumentMustBeMethodGroupOrLambda, actionExpression.GetLocation());
                            return result;
                        }
                    }

                    return result;
                })
            .Collect();

        context.RegisterSourceOutput(queryMethodProvider, EmitRegisterFunctionMethod);
    }

    void EmitRegisterFunctionMethod(SourceProductionContext context, ImmutableArray<CreateFunctionContext> methodContexts)
    {
        var methods = new HashSet<CreateFunctionMethod>();
        var cases = new CodeBuilder(0);
        var id = 0;

        foreach (var methodContext in methodContexts)
        {
            // check compilation errors
            if (methodContext.DiagnosticReporter.HasDiagnostics)
            {
                methodContext.DiagnosticReporter.ReportToContext(context);
                continue;
            }

            // check method is valid
            var method = methodContext.Method;
            if (method == null) continue;

            if (!methods.Add(method)) return;

            var delegateType = method.HasReturnValue || method.IsAsync
                ? $"global::System.Func<{string.Join(", ", method.Parameters.Select(x => x.FullTypeName))}, {(method.IsAsync && !method.HasReturnValue ? "global::System.Threading.Tasks.Task" : method.ReturnTypeName)}>"
                : method.Parameters.Length == 0 ? "global::System.Action" : $"global::System.Action<{string.Join(", ", method.Parameters.Select(x => x.FullTypeName))}>";

            var argsDeclaration = string.Join("\n", method.Parameters.Select((x, i) =>
            {
                const string ctType = "global::System.Threading.CancellationToken";
                if (x.FullTypeName == ctType)
                {
                    return $"var arg{i} = ct;";
                }
                else
                {
                    var count = method.Parameters.Count(x => x.FullTypeName != ctType);
                    return $"var arg{i} = state.ToValue({i - count}).Read<{x.FullTypeName}>();";
                }
            }));

            var actionCall = $"{(method.HasReturnValue ? "var result = " : "")} " +
                (method.IsAsync ? "await " : "") +
                $"(({delegateType})action)({string.Join(", ", method.Parameters.Select((x, i) => $"arg{i}"))});";

            var pushResult = method.HasReturnValue ? "state.Push(state.CreateFrom(result));" : "";

            cases.AppendLine(
$$"""
            case ("{{method.FilePath}}", {{method.LineNumber}}):
                return state.CreateFunction({{(method.IsAsync ? "async (state, ct)" : "state")}} =>
                {
                    {{argsDeclaration}}
                    {{actionCall}}
                    {{pushResult}}
                    return {{(method.HasReturnValue ? 1 : 0)}};
                });
""");

            id++;
        }

        var source =
$$"""
// <auto-generated/>

#pragma warning disable CS1522

namespace Luau
{
    internal static partial class GeneratedLuauStateExtensions
    {
        public static partial global::Luau.LuauFunction CreateFunction(
            this global::Luau.LuauState state,
            global::System.Delegate action,
            string filePath, 
            int lineNumber)
        {
            switch ((filePath, lineNumber))
            {
{{cases}}
            }

            throw new global::System.NotSupportedException();
        }
    }
}
""";

        context.AddSource($"GeneratedLuauStateExtensions.RegisterFunction.Impl.g.cs", source);
    }
}